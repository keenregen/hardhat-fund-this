{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/FundThis.sol": {
      "content": "// SPDX-License-Identifier: Blank\n\n// pragma\npragma solidity 0.8.7;\n\n//imports\nimport \"./PriceConverterLib.sol\";\n\n// error codes\nerror FundThis__NotDeployer();\n\n// get funds from blch users\n// set a min funding value in usd\n// keep funder addresses and fund amounts\n// withdraw funds\n\n// v3 with gas efficiency techniques, receive and fallback additions\n\n// Interfaces\n\n// Libraries\n\n// Contracts\n/// @title A Contract For Funding The Contract\n/// @author keenregen_study\n/// @notice A simple funding contract for study purposes\n/// @dev Price feeds are implemented as library\n/// @custom:experimental This is an experimental contract.\ncontract FundThis {\n     // Type Declerations\n     // PriceConvertLib usage for uint256\n     using PriceConverterLib for uint256;\n\n     // State Vars\n     // constants, privates and intertnals are better for gas efficiency\n     uint256 public constant MIN_USD = 1 * 1e18;\n\n     address[] private s_funders;\n     mapping(address => uint256) private s_addressToAmountFunded;\n\n     // immutables are better for gas efficiency\n     address private immutable i_deployer;\n\n     AggregatorV3Interface private s_priceFeed;\n\n     modifier onlyDeployer() {\n          // require(msg.sender == i_deployer, \"Sender must be contract deployer.\");\n          // gas efficient way for errors\n          if (msg.sender != i_deployer) revert FundThis__NotDeployer();\n          _;\n     }\n\n     // Functions (const, rec, fallback, external, public, internal, private, view/pure)\n\n     // called when the contract is deployed\n     constructor(address priceFeedAddress) {\n          i_deployer = msg.sender;\n          s_priceFeed = AggregatorV3Interface(priceFeedAddress);\n     }\n\n     receive() external payable {\n          fund();\n     }\n\n     fallback() external payable {\n          fund();\n     }\n\n     /// @notice function to fund this contract\n     /// @dev Price feeds are implemented as library\n     function fund() public payable {\n          // set min funding value with require keyword\n          // if require condition is not met, the ops before are undone and gas remaining is sent back\n          // msg.value : how much money is added to be sent\n          require(\n               msg.value.getConverted(s_priceFeed) >= MIN_USD,\n               \"min $1 is needed\"\n          ); // 1e18 = 1 * 10 * 10**18 wei = 1 ETH\n          s_funders.push(msg.sender);\n          s_addressToAmountFunded[msg.sender] += msg.value;\n     }\n\n     function withdraw() public payable onlyDeployer {\n          // withdraw the funds (msg.sender should be casted to payable)\n          // 1. Method: Transfer (max 2300 gas; if fails reverts the transaction)\n          // payable(msg.sender).transfer(address(this).balance);\n          // 2. Method: Send (max 2300 gas; if fails returns a bool)\n          // bool sendingSuccess = payable(msg.sender).send(address(this).balance);\n          // require(sendingSuccess, \"Sending failed\");\n          // 3. Method: Call (forward all gas or set gas, returns bool) (recommended)\n          (bool callSuccess /* bytes memory dataReturned */, ) = payable(\n               msg.sender\n          ).call{value: address(this).balance}(\"\");\n          require(callSuccess, \"Sending failed\");\n\n          // reset the amounts funded\n          for (\n               uint256 funderIndex = 0;\n               funderIndex < s_funders.length;\n               funderIndex++\n          ) {\n               s_addressToAmountFunded[s_funders[funderIndex]] = 0;\n          }\n\n          // reset the funders array\n          s_funders = new address[](0);\n     }\n\n     function gasEfficWithdraw() public payable onlyDeployer {\n          address[] memory funders = s_funders;\n          // mapping cannot be in memory\n          for (\n               uint256 funderIndex = 0;\n               funderIndex < funders.length;\n               funderIndex++\n          ) {\n               s_addressToAmountFunded[funders[funderIndex]] = 0;\n          }\n          // reset the funders array\n          s_funders = new address[](0);\n     }\n\n     function getDeployer() public view returns (address) {\n          return i_deployer;\n     }\n\n     function getFunder(uint256 index) public view returns (address) {\n          return s_funders[index];\n     }\n\n     function getAmountFunded(\n          address funderAddress\n     ) public view returns (uint256) {\n          return s_addressToAmountFunded[funderAddress];\n     }\n\n     function getPriceFeed() public view returns (AggregatorV3Interface) {\n          return s_priceFeed;\n     }\n}\n"
    },
    "contracts/PriceConverterLib.sol": {
      "content": "// Price Converter Library\n// Libraries cannot have any state vars nor cannot send ETH\n\n// SPDX-License-Identifier: Blank\n\npragma solidity 0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverterLib {\n     function getPrice(\n          AggregatorV3Interface priceFeed\n     ) internal view returns (uint256) {\n          // abi\n          // a contract address 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e  (eth / usd goerli testnet)\n          (, int256 price, , , ) = priceFeed.latestRoundData();\n          // ETH in usd (8 decimal places, should be 18 dec places as ETH and should be uint256 as ETH)\n          return uint256(price) * 1e10;\n     }\n\n     function getConverted(\n          uint256 ethAmount,\n          AggregatorV3Interface priceFeed\n     ) internal view returns (uint256) {\n          // ETH in USD\n          uint256 ethAmountInUsd = (getPrice(priceFeed) * ethAmount) / 1e18;\n          return ethAmountInUsd;\n     }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}